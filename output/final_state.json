{
  "user_request": "I want to see which suppliers are indirectly responsible for the most delayed shipments in the last year. For each supplier, show me the number of delayed shipments, the percentage compared to their total shipments, which warehouses handled those shipments, and which top 3 customers were most affected.",
  "general_context": "## **High-Level Context**\n\nThis database manages **products, warehouses, suppliers, customers, orders, shipments, stock movements, purchases, and user actions**. It\u00e2\u20ac\u2122s structured to support a real-world logistics flow:\n\n1. **Products are stocked in warehouses.**\n2. **Customers place orders.**\n3. Orders get fulfilled from inventory \u00e2\u2020\u2019 shipments go out.\n4. **Suppliers send goods** via purchase orders \u00e2\u2020\u2019 stock gets restocked.\n5. All movements (inbound/outbound/transfer/adjustments) are tracked with **audits**.\n6. **Users** (staff, managers, drivers) interact with the system, and their actions are logged.\n\n---\n\n## **Core Entities**\n\n### **Warehouses**\n\n* Stores products.\n* Has name, code, location (with optional lat/long), and capacity.\n* Auto-updates timestamps on changes.\n* Represents physical stock locations.\n\n### **Suppliers**\n\n* Companies or vendors providing goods.\n* Contact details + rating.\n* Linked to **purchase orders**.\n\n### **Customers**\n\n* Either `individual` or `business`.\n* Stores contact + location (lat/long available for routing/shipments).\n* Linked to **orders**.\n\n---\n\n## **Products & Inventory**\n\n### **Products**\n\n* Each product has SKU, name, category, weight, volume, unit price.\n* Has a **reorder level** (triggers restocking logic).\n* Core unit of stock across the system.\n\n### **Inventory**\n\n* Links `product` + `warehouse`.\n* Tracks:\n\n  * `quantity` (on hand),\n  * `reserved_qty` (allocated for orders),\n  * `last_updated`.\n* Unique per (warehouse, product).\n* Trigger prevents `reserved_qty` > `quantity`.\n\n---\n\n## **Orders & Fulfillment**\n\n### **Orders**\n\n* Placed by customers.\n* Lifecycle status: `pending \u00e2\u2020\u2019 allocated \u00e2\u2020\u2019 shipped \u00e2\u2020\u2019 delivered` (or `cancelled`).\n* Priority field for urgent handling.\n* Timestamps for order/shipped/delivered.\n\n### **Order Items**\n\n* Each order consists of multiple products.\n* Tracks ordered `quantity`, `unit_price`, and `allocated_qty` (reserved for fulfillment).\n* Trigger prevents allocation beyond ordered quantity.\n\n---\n\n## **Shipments & Tracking**\n\n### **Shipments**\n\n* Tied to both an `order` and a `warehouse`.\n* Tracks carrier, tracking number, and shipment status:\n  (`preparing \u00e2\u2020\u2019 in_transit \u00e2\u2020\u2019 delivered` or `failed`).\n* Has ship, expected, and delivered dates.\n\n### **Shipment Items**\n\n* Line items inside a shipment.\n* Maps products to quantities shipped.\n\n---\n\n## **Purchases & Restocking**\n\n### **Purchase Orders**\n\n* Created for suppliers \u00e2\u2020\u2019 warehouses.\n* Lifecycle: `requested \u00e2\u2020\u2019 approved \u00e2\u2020\u2019 shipped \u00e2\u2020\u2019 received` (or `cancelled`).\n* Dates for order/receipt.\n\n### **Purchase Order Items**\n\n* Products requested from suppliers.\n* Quantity + unit price (procurement details).\n\n---\n\n## **Movements & Audits**\n\n### **Stock Movements**\n\n* Tracks **all product flows** in/out of warehouses:\n\n  * `inbound` (e.g., supplier delivery),\n  * `outbound` (customer order),\n  * `transfer` (between warehouses),\n  * `adjustment` (manual fix).\n* Reference system (order, purchase, shipment, or manual).\n* Keeps notes + timestamp.\n\n### **Inventory Audits**\n\n* Physical vs. system check.\n* Stores discrepancy values.\n* Records auditor + audit date.\n\n---\n\n## **Users & Permissions**\n\n### **Users**\n\n* System users: roles (`admin`, `manager`, `staff`, `driver`).\n* Stores username, password hash, contact info.\n* Created\\_at timestamp.\n\n### **User Actions**\n\n* Logs what users do in the system.\n* Stores action type, target table/id, details, timestamp.\n* Keeps a full audit trail.\n\n---\n\n## **Indices & Performance**\n\n* Indexed for efficient lookups:\n\n  * inventory by warehouse/product\n  * orders by customer\n  * order\\_items by order/product\n  * shipments by order\n  * stock movements by warehouse/product\n  * products by SKU\n* Supports fast joins and retrievals for core flows.\n\n---\n\n## **Triggers & Constraints**\n\n* **Auto-timestamps**: warehouses, inventory.\n* **Guards**:\n\n  * reserved stock \u00e2\u2030\u00a4 available stock,\n  * allocated \u00e2\u2030\u00a4 ordered quantity.\n* These prevent data corruption during stock handling.\n\n---\n\n## **Business Flow Example**\n\n1. **Purchase order** created \u00e2\u2020\u2019 supplier ships \u00e2\u2020\u2019 stock increases (`inbound` movement).\n2. **Customer order** created \u00e2\u2020\u2019 system allocates stock (`reserved_qty`) \u00e2\u2020\u2019 shipment created.\n3. Shipment moves to `in_transit` \u00e2\u2020\u2019 upon delivery, `outbound` movement recorded.\n4. Inventory audits ensure stock accuracy.\n5. Users\u00e2\u20ac\u2122 actions are logged for accountability.\n",
  "schema_snapshot": "PRAGMA foreign_keys = ON;\n\nBEGIN;\n\n-- =========================\n-- 1) Entities & Core Tables\n-- =========================\n\nCREATE TABLE IF NOT EXISTS warehouses (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    name            TEXT NOT NULL,\n    code            TEXT UNIQUE NOT NULL,\n    location        TEXT NOT NULL,\n    latitude        REAL,\n    longitude       REAL,\n    capacity        INTEGER,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS suppliers (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    name            TEXT NOT NULL,\n    contact_name    TEXT,\n    phone           TEXT,\n    email           TEXT,\n    address         TEXT,\n    rating          REAL NOT NULL DEFAULT 0.0,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS customers (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    name            TEXT NOT NULL,\n    type            TEXT NOT NULL CHECK (type IN ('individual','business')),\n    contact_name    TEXT,\n    phone           TEXT,\n    email           TEXT,\n    address         TEXT NOT NULL,\n    latitude        REAL,\n    longitude       REAL,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\n-- =========================\n-- 2) Products & Inventory\n-- =========================\n\nCREATE TABLE IF NOT EXISTS products (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    sku             TEXT NOT NULL UNIQUE,\n    name            TEXT NOT NULL,\n    description     TEXT,\n    category        TEXT,\n    weight          REAL,\n    volume          REAL,\n    unit_price      REAL NOT NULL CHECK (unit_price >= 0),\n    reorder_level   INTEGER NOT NULL DEFAULT 10 CHECK (reorder_level >= 0),\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS inventory (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE CASCADE,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE CASCADE,\n    quantity        INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),\n    reserved_qty    INTEGER NOT NULL DEFAULT 0 CHECK (reserved_qty >= 0),\n    last_updated    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE (warehouse_id, product_id)\n);\n\n-- =========================\n-- 3) Orders & Fulfillment\n-- =========================\n\nCREATE TABLE IF NOT EXISTS orders (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    customer_id     INTEGER NOT NULL REFERENCES customers(id) ON DELETE RESTRICT,\n    status          TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending','allocated','shipped','delivered','cancelled')),\n    priority        INTEGER NOT NULL DEFAULT 0,\n    order_date      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    shipped_date    DATETIME,\n    delivered_date  DATETIME\n);\n\nCREATE TABLE IF NOT EXISTS order_items (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    order_id        INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    quantity        INTEGER NOT NULL CHECK (quantity > 0),\n    unit_price      REAL NOT NULL CHECK (unit_price >= 0),\n    allocated_qty   INTEGER NOT NULL DEFAULT 0 CHECK (allocated_qty >= 0)\n);\n\n-- =========================\n-- 4) Shipments & Tracking\n-- =========================\n\nCREATE TABLE IF NOT EXISTS shipments (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    order_id        INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    carrier         TEXT,\n    tracking_number TEXT,\n    status          TEXT NOT NULL DEFAULT 'preparing' CHECK (status IN ('preparing','in_transit','delivered','failed')),\n    ship_date       DATETIME,\n    expected_date   DATETIME,\n    delivered_date  DATETIME\n);\n\nCREATE TABLE IF NOT EXISTS shipment_items (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    shipment_id     INTEGER NOT NULL REFERENCES shipments(id) ON DELETE CASCADE,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    quantity        INTEGER NOT NULL CHECK (quantity > 0)\n);\n\n-- =========================\n-- 5) Purchases & Restocking\n-- =========================\n\nCREATE TABLE IF NOT EXISTS purchase_orders (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    supplier_id     INTEGER NOT NULL REFERENCES suppliers(id) ON DELETE RESTRICT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    status          TEXT NOT NULL DEFAULT 'requested' CHECK (status IN ('requested','approved','shipped','received','cancelled')),\n    order_date      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    received_date   DATETIME\n);\n\nCREATE TABLE IF NOT EXISTS purchase_order_items (\n    id                  INTEGER PRIMARY KEY AUTOINCREMENT,\n    purchase_order_id   INTEGER NOT NULL REFERENCES purchase_orders(id) ON DELETE CASCADE,\n    product_id          INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    quantity            INTEGER NOT NULL CHECK (quantity > 0),\n    unit_price          REAL NOT NULL CHECK (unit_price >= 0)\n);\n\n-- =========================\n-- 6) Movements & Audits\n-- =========================\n\nCREATE TABLE IF NOT EXISTS stock_movements (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    movement_type   TEXT NOT NULL CHECK (movement_type IN ('inbound','outbound','transfer','adjustment')),\n    quantity        INTEGER NOT NULL CHECK (quantity <> 0),\n    reference_id    INTEGER,\n    reference_type  TEXT CHECK (reference_type IN ('order','purchase','shipment','manual')),\n    timestamp       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    notes           TEXT\n);\n\nCREATE TABLE IF NOT EXISTS inventory_audits (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    system_qty      INTEGER NOT NULL,\n    physical_qty    INTEGER NOT NULL,\n    discrepancy     INTEGER NOT NULL,\n    audit_date      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    auditor         TEXT\n);\n\n-- =========================\n-- 7) Users & Permissions\n-- =========================\n\nCREATE TABLE IF NOT EXISTS users (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    username        TEXT NOT NULL UNIQUE,\n    password_hash   TEXT NOT NULL,\n    role            TEXT NOT NULL CHECK (role IN ('admin','manager','staff','driver')),\n    full_name       TEXT,\n    email           TEXT UNIQUE,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS user_actions (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    user_id         INTEGER NOT NULL REFERENCES users(id) ON DELETE SET NULL,\n    action          TEXT NOT NULL,\n    target_table    TEXT,\n    target_id       INTEGER,\n    timestamp       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    details         TEXT\n);\n\n-- =========================\n-- 8) Indices\n-- =========================\n\nCREATE INDEX IF NOT EXISTS idx_inventory_wh_product ON inventory(warehouse_id, product_id);\nCREATE INDEX IF NOT EXISTS idx_orders_customer ON orders(customer_id);\nCREATE INDEX IF NOT EXISTS idx_order_items_order ON order_items(order_id);\nCREATE INDEX IF NOT EXISTS idx_order_items_product ON order_items(product_id);\nCREATE INDEX IF NOT EXISTS idx_shipments_order ON shipments(order_id);\nCREATE INDEX IF NOT EXISTS idx_purchase_orders_supplier ON purchase_orders(supplier_id);\nCREATE INDEX IF NOT EXISTS idx_stock_movements_wh_prod ON stock_movements(warehouse_id, product_id);\nCREATE INDEX IF NOT EXISTS idx_products_sku ON products(sku);\n\n-- =========================\n-- 9) Triggers (timestamps & guards)\n-- =========================\n\n-- warehouses.updated_at auto-update\nCREATE TRIGGER IF NOT EXISTS trg_warehouses_updated_at\nAFTER UPDATE ON warehouses\nFOR EACH ROW\nBEGIN\n    UPDATE warehouses SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;\nEND;\n\n-- inventory.last_updated auto-update\nCREATE TRIGGER IF NOT EXISTS trg_inventory_last_updated\nAFTER UPDATE ON inventory\nFOR EACH ROW\nBEGIN\n    UPDATE inventory SET last_updated = CURRENT_TIMESTAMP WHERE id = NEW.id;\nEND;\n\n-- Prevent reserved > quantity\nCREATE TRIGGER IF NOT EXISTS trg_inventory_reserved_guard\nBEFORE UPDATE ON inventory\nFOR EACH ROW\nBEGIN\n    SELECT\n        CASE\n            WHEN NEW.reserved_qty > NEW.quantity THEN\n                RAISE(ABORT, 'reserved_qty cannot exceed quantity')\n        END;\nEND;\n\n-- Keep allocated_qty within order item quantity\nCREATE TRIGGER IF NOT EXISTS trg_order_items_alloc_guard\nBEFORE UPDATE ON order_items\nFOR EACH ROW\nBEGIN\n    SELECT\n        CASE\n            WHEN NEW.allocated_qty > NEW.quantity THEN\n                RAISE(ABORT, 'allocated_qty cannot exceed ordered quantity')\n        END;\nEND;\n\nCOMMIT;",
  "example_queries": "-- 1. Top 5 customers by total order value\nSELECT T2.name, SUM(T3.quantity * T3.unit_price) AS total_value FROM orders AS T1 INNER JOIN customers AS T2 ON T1.customer_id = T2.id INNER JOIN order_items AS T3 ON T1.id = T3.order_id GROUP BY T2.id ORDER BY total_value DESC LIMIT 5;\n\n-- 2. Products that are below reorder level and not restocked recently\nSELECT T1.name, T2.quantity AS stock_quantity, T1.reorder_level, MAX(T3.timestamp) AS last_inbound_date FROM products AS T1 INNER JOIN inventory AS T2 ON T1.id = T2.product_id LEFT JOIN stock_movements AS T3 ON T1.id = T3.product_id WHERE T2.quantity < T1.reorder_level AND T3.movement_type = 'inbound' GROUP BY T1.id HAVING last_inbound_date < strftime('%Y-%m-%d %H:%M:%S', date('now', '-30 days'));\n\n-- 3. Average order value per customer\nSELECT T2.name, AVG(T1.order_value) AS avg_order FROM (SELECT T1.id, T1.customer_id, SUM(T2.quantity * T2.unit_price) AS order_value FROM orders AS T1 INNER JOIN order_items AS T2 ON T1.id = T2.order_id GROUP BY T1.id) AS T1 INNER JOIN customers AS T2 ON T1.customer_id = T2.id GROUP BY T2.id;\n\n-- 4. Employees with most shipments handled\nSELECT T1.carrier, COUNT(T1.id) AS shipments FROM shipments AS T1 GROUP BY T1.carrier ORDER BY shipments DESC LIMIT 5;\n\n-- 5. Products with no orders in the last 6 months\nSELECT T1.name FROM products AS T1 WHERE NOT EXISTS (SELECT 1 FROM order_items AS T2 INNER JOIN orders AS T3 ON T2.order_id = T3.id WHERE T2.product_id = T1.id AND T3.order_date >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-6 months')));\n\n-- 6. Warehouse stock value by warehouse\nSELECT T1.name, SUM(T2.quantity * T3.unit_price) AS warehouse_value FROM warehouses AS T1 INNER JOIN inventory AS T2 ON T1.id = T2.warehouse_id INNER JOIN products AS T3 ON T2.product_id = T3.id GROUP BY T1.id ORDER BY warehouse_value DESC;\n\n-- 7. Orders that were delayed more than 7 days from order to shipment\nSELECT T1.id, T2.name, T1.order_date, T1.shipped_date FROM orders AS T1 INNER JOIN customers AS T2 ON T1.customer_id = T2.id WHERE JULIANDAY(T1.shipped_date) - JULIANDAY(T1.order_date) > 7;\n\n-- 8. Suppliers with top 3 most expensive products\nSELECT name, product_name, unit_price FROM (SELECT T1.name, T2.name AS product_name, T2.unit_price, DENSE_RANK() OVER (PARTITION BY T1.id ORDER BY T2.unit_price DESC) AS rank FROM suppliers AS T1 INNER JOIN purchase_order_items AS T3 ON T1.id = T3.purchase_order_id INNER JOIN products AS T2 ON T3.product_id = T2.id) AS T1 WHERE rank <= 3;\n\n-- 9. Monthly sales revenue trend\nSELECT strftime('%Y-%m', T1.order_date) AS month, SUM(T2.quantity * T2.unit_price) AS revenue FROM orders AS T1 INNER JOIN order_items AS T2 ON T1.id = T2.order_id GROUP BY month ORDER BY month;\n\n-- 10. Customers who ordered from multiple warehouses\nSELECT T1.name, COUNT(DISTINCT T3.warehouse_id) AS warehouse_count FROM customers AS T1 INNER JOIN orders AS T2 ON T1.id = T2.customer_id INNER JOIN shipments AS T3 ON T2.id = T3.order_id GROUP BY T1.id HAVING warehouse_count > 1;",
  "process": [
    "[SQL] Retrieve the following for each supplier for shipments in the last year (ship_date within the last year): supplier_id, supplier_name, total_shipments_count (total unique shipments linked to the supplier), delayed_shipments_count (total unique delayed shipments linked to the supplier, where delivered_date > expected_date), delayed_warehouses_names (comma-separated list of unique warehouse names involved in delayed shipments for that supplier), and delayed_customer_ids_list (comma-separated list of customer IDs involved in delayed shipments for that supplier, including duplicates for frequency counting). This query will join `shipments`, `orders`, `order_items`, `products`, `purchase_order_items`, `purchase_orders`, `suppliers`, and `warehouses` tables.",
    "[ANALYZE] Process the SQL query results. For each supplier, calculate the percentage of delayed shipments. Parse the `delayed_customer_ids_list` to determine the top 3 most affected customers by counting the frequency of each customer ID. Retrieve the names of these top 3 customers using a separate database query. Format the final output to include the supplier's name, the number of delayed shipments, the percentage of delayed shipments, the warehouses that handled those delayed shipments, and the names of the top 3 most affected customers. Order the suppliers by the number of delayed shipments in descending order."
  ],
  "plan": {
    "version": "1.0",
    "nodes": [
      {
        "id": "n1_get_delayed_shipments_data",
        "type": "SQL",
        "label": "Retrieve raw data on delayed shipments per supplier",
        "requires": "",
        "produces": "result_delayed_shipments_raw",
        "input": "Generate a SQL query to retrieve the following for each supplier for shipments in the last year (ship_date within the last year): supplier_id, supplier_name, total_shipments_count (total unique shipments linked to the supplier), delayed_shipments_count (total unique delayed shipments linked to the supplier, where delivered_date > expected_date), delayed_warehouses_names (comma-separated list of unique warehouse names involved in delayed shipments for that supplier), and delayed_customer_ids_list (comma-separated list of customer IDs involved in delayed shipments for that supplier, including duplicates for frequency counting). This query will join shipments, orders, order_items, products, purchase_order_items, purchase_orders, suppliers, and warehouses tables. Ensure ship_date is within the last year from CURRENT_DATE."
      },
      {
        "id": "n2_analyze_delayed_shipments",
        "type": "SQL_RESULT_ANALYZER",
        "label": "Process delayed shipment data and identify top customers",
        "requires": "result_delayed_shipments_raw",
        "produces": "summary_delayed_shipments_processed",
        "input": "Process the SQL query results from 'result_delayed_shipments_raw'. For each supplier, calculate the percentage of delayed shipments (delayed_shipments_count / total_shipments_count * 100). Parse the 'delayed_customer_ids_list' to determine the top 3 most affected customer IDs by counting the frequency of each customer ID. The output should be a structured object (e.g., JSON array) where each element represents a supplier and includes: supplier_id, supplier_name, delayed_shipments_count, percentage_delayed_shipments, delayed_warehouses_names, and a list of the top 3 customer IDs (e.g., [customer_id_1, customer_id_2, customer_id_3])."
      },
      {
        "id": "n3_get_customer_names",
        "type": "SQL",
        "label": "Retrieve names for identified top customers",
        "requires": "summary_delayed_shipments_processed",
        "produces": "result_customer_names_raw",
        "input": "Extract all unique customer IDs from the 'summary_delayed_shipments_processed' artifact. Generate a SQL query to retrieve the 'id' and 'name' for these specific customer IDs from the 'customers' table. The query should return two columns: customer_id and customer_name."
      },
      {
        "id": "n4_analyze_customer_names",
        "type": "SQL_RESULT_ANALYZER",
        "label": "Map customer IDs to names",
        "requires": "result_customer_names_raw",
        "produces": "summary_customer_names",
        "input": "Process the raw SQL results from 'result_customer_names_raw'. Create a mapping (e.g., a dictionary or JSON object) where keys are customer IDs and values are their corresponding customer names."
      },
      {
        "id": "n5_format_final_output",
        "type": "ANALYZER",
        "label": "Generate final report of suppliers and delayed shipments",
        "requires": "summary_delayed_shipments_processed,summary_customer_names",
        "produces": "final_report",
        "input": "Combine the information from 'summary_delayed_shipments_processed' and 'summary_customer_names'. For each supplier in 'summary_delayed_shipments_processed', replace the top 3 customer IDs with their corresponding names using the mapping from 'summary_customer_names'. Format the final output as a human-readable report (e.g., a markdown table or a clear list of entries) including the supplier's name, the number of delayed shipments, the percentage of delayed shipments, the warehouses that handled those delayed shipments, and the names of the top 3 most affected customers. Order the suppliers by the number of delayed shipments in descending order."
      }
    ],
    "edges": [
      [
        "n1_get_delayed_shipments_data",
        "n2_analyze_delayed_shipments"
      ],
      [
        "n2_analyze_delayed_shipments",
        "n3_get_customer_names"
      ],
      [
        "n3_get_customer_names",
        "n4_analyze_customer_names"
      ],
      [
        "n2_analyze_delayed_shipments",
        "n5_format_final_output"
      ],
      [
        "n4_analyze_customer_names",
        "n5_format_final_output"
      ]
    ]
  },
  "artifacts": {},
  "executed_queries": [
    "WITH SupplierShipmentDetails AS (\n    SELECT\n        s.id AS supplier_id,\n        s.name AS supplier_name,\n        sh.id AS shipment_id,\n        sh.ship_date,\n        sh.expected_date,\n        sh.delivered_date,\n        w.name AS warehouse_name,\n        o.customer_id,\n        CASE\n            WHEN sh.delivered_date IS NOT NULL AND sh.expected_date IS NOT NULL AND sh.delivered_date > sh.expected_date THEN 1\n            ELSE 0\n        END AS is_delayed\n    FROM\n        suppliers AS s\n    INNER JOIN\n        purchase_orders AS po ON s.id = po.supplier_id\n    INNER JOIN\n        purchase_order_items AS poi ON po.id = poi.purchase_order_id\n    INNER JOIN\n        products AS p ON poi.product_id = p.id\n    INNER JOIN\n        order_items AS oi ON p.id = oi.product_id\n    INNER JOIN\n        orders AS o ON oi.order_id = o.id\n    INNER JOIN\n        shipments AS sh ON o.id = sh.order_id\n    INNER JOIN\n        warehouses AS w ON sh.warehouse_id = w.id\n    WHERE\n        sh.ship_date >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-1 year'))\n)\nSELECT\n    ssd.supplier_id,\n    ssd.supplier_name,\n    COUNT(DISTINCT ssd.shipment_id) AS total_shipments_count,\n    SUM(CASE WHEN ssd.is_delayed = 1 THEN 1 ELSE 0 END) AS delayed_shipments_count,\n    CASE\n        WHEN COUNT(DISTINCT ssd.shipment_id) > 0 THEN\n            CAST(SUM(CASE WHEN ssd.is_delayed = 1 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(DISTINCT ssd.shipment_id)\n        ELSE 0.0\n    END AS percentage_compared_to_total_shipments,\n    GROUP_CONCAT(DISTINCT CASE WHEN ssd.is_delayed = 1 THEN ssd.warehouse_name END) AS delayed_warehouses_names,\n    GROUP_CONCAT(CASE WHEN ssd.is_delayed = 1 THEN ssd.customer_id END) AS delayed_customer_ids_list\nFROM\n    SupplierShipmentDetails AS ssd\nGROUP BY\n    ssd.supplier_id, ssd.supplier_name\nHAVING\n    delayed_shipments_count > 0\nORDER BY\n    delayed_shipments_count DESC;"
  ],
  "node_status": {
    "n1_get_delayed_shipments_data": {
      "state": "succeeded",
      "attempts": 1,
      "last_error": null
    },
    "n2_analyze_delayed_shipments": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    },
    "n3_get_customer_names": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    },
    "n4_analyze_customer_names": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    },
    "n5_format_final_output": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    }
  },
  "current_node_id": "n1_get_delayed_shipments_data",
  "last_output": {
    "status": "ok",
    "artifacts": {},
    "notes": "Retrieves suppliers indirectly responsible for the most delayed shipments in the last year, including counts, percentage, associated warehouses, and affected customer IDs.",
    "stats": {
      "elapsed_ms": 4,
      "rows_affected": -1
    },
    "error": null
  },
  "total_attempts": 1,
  "issues": []
}