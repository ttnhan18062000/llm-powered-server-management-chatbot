{
  "user_request": "I want to see which suppliers are indirectly responsible for the most delayed shipments in the last year. For each supplier, show me the number of delayed shipments, the percentage compared to their total shipments, which warehouses handled those shipments, and which top 3 customers were most affected.",
  "general_context": "## **High-Level Context**\n\nThis database manages **products, warehouses, suppliers, customers, orders, shipments, stock movements, purchases, and user actions**. It\u00e2\u20ac\u2122s structured to support a real-world logistics flow:\n\n1. **Products are stocked in warehouses.**\n2. **Customers place orders.**\n3. Orders get fulfilled from inventory \u00e2\u2020\u2019 shipments go out.\n4. **Suppliers send goods** via purchase orders \u00e2\u2020\u2019 stock gets restocked.\n5. All movements (inbound/outbound/transfer/adjustments) are tracked with **audits**.\n6. **Users** (staff, managers, drivers) interact with the system, and their actions are logged.\n\n---\n\n## **Core Entities**\n\n### **Warehouses**\n\n* Stores products.\n* Has name, code, location (with optional lat/long), and capacity.\n* Auto-updates timestamps on changes.\n* Represents physical stock locations.\n\n### **Suppliers**\n\n* Companies or vendors providing goods.\n* Contact details + rating.\n* Linked to **purchase orders**.\n\n### **Customers**\n\n* Either `individual` or `business`.\n* Stores contact + location (lat/long available for routing/shipments).\n* Linked to **orders**.\n\n---\n\n## **Products & Inventory**\n\n### **Products**\n\n* Each product has SKU, name, category, weight, volume, unit price.\n* Has a **reorder level** (triggers restocking logic).\n* Core unit of stock across the system.\n\n### **Inventory**\n\n* Links `product` + `warehouse`.\n* Tracks:\n\n  * `quantity` (on hand),\n  * `reserved_qty` (allocated for orders),\n  * `last_updated`.\n* Unique per (warehouse, product).\n* Trigger prevents `reserved_qty` > `quantity`.\n\n---\n\n## **Orders & Fulfillment**\n\n### **Orders**\n\n* Placed by customers.\n* Lifecycle status: `pending \u00e2\u2020\u2019 allocated \u00e2\u2020\u2019 shipped \u00e2\u2020\u2019 delivered` (or `cancelled`).\n* Priority field for urgent handling.\n* Timestamps for order/shipped/delivered.\n\n### **Order Items**\n\n* Each order consists of multiple products.\n* Tracks ordered `quantity`, `unit_price`, and `allocated_qty` (reserved for fulfillment).\n* Trigger prevents allocation beyond ordered quantity.\n\n---\n\n## **Shipments & Tracking**\n\n### **Shipments**\n\n* Tied to both an `order` and a `warehouse`.\n* Tracks carrier, tracking number, and shipment status:\n  (`preparing \u00e2\u2020\u2019 in_transit \u00e2\u2020\u2019 delivered` or `failed`).\n* Has ship, expected, and delivered dates.\n\n### **Shipment Items**\n\n* Line items inside a shipment.\n* Maps products to quantities shipped.\n\n---\n\n## **Purchases & Restocking**\n\n### **Purchase Orders**\n\n* Created for suppliers \u00e2\u2020\u2019 warehouses.\n* Lifecycle: `requested \u00e2\u2020\u2019 approved \u00e2\u2020\u2019 shipped \u00e2\u2020\u2019 received` (or `cancelled`).\n* Dates for order/receipt.\n\n### **Purchase Order Items**\n\n* Products requested from suppliers.\n* Quantity + unit price (procurement details).\n\n---\n\n## **Movements & Audits**\n\n### **Stock Movements**\n\n* Tracks **all product flows** in/out of warehouses:\n\n  * `inbound` (e.g., supplier delivery),\n  * `outbound` (customer order),\n  * `transfer` (between warehouses),\n  * `adjustment` (manual fix).\n* Reference system (order, purchase, shipment, or manual).\n* Keeps notes + timestamp.\n\n### **Inventory Audits**\n\n* Physical vs. system check.\n* Stores discrepancy values.\n* Records auditor + audit date.\n\n---\n\n## **Users & Permissions**\n\n### **Users**\n\n* System users: roles (`admin`, `manager`, `staff`, `driver`).\n* Stores username, password hash, contact info.\n* Created\\_at timestamp.\n\n### **User Actions**\n\n* Logs what users do in the system.\n* Stores action type, target table/id, details, timestamp.\n* Keeps a full audit trail.\n\n---\n\n## **Indices & Performance**\n\n* Indexed for efficient lookups:\n\n  * inventory by warehouse/product\n  * orders by customer\n  * order\\_items by order/product\n  * shipments by order\n  * stock movements by warehouse/product\n  * products by SKU\n* Supports fast joins and retrievals for core flows.\n\n---\n\n## **Triggers & Constraints**\n\n* **Auto-timestamps**: warehouses, inventory.\n* **Guards**:\n\n  * reserved stock \u00e2\u2030\u00a4 available stock,\n  * allocated \u00e2\u2030\u00a4 ordered quantity.\n* These prevent data corruption during stock handling.\n\n---\n\n## **Business Flow Example**\n\n1. **Purchase order** created \u00e2\u2020\u2019 supplier ships \u00e2\u2020\u2019 stock increases (`inbound` movement).\n2. **Customer order** created \u00e2\u2020\u2019 system allocates stock (`reserved_qty`) \u00e2\u2020\u2019 shipment created.\n3. Shipment moves to `in_transit` \u00e2\u2020\u2019 upon delivery, `outbound` movement recorded.\n4. Inventory audits ensure stock accuracy.\n5. Users\u00e2\u20ac\u2122 actions are logged for accountability.\n",
  "schema_snapshot": "PRAGMA foreign_keys = ON;\n\nBEGIN;\n\n-- =========================\n-- 1) Entities & Core Tables\n-- =========================\n\nCREATE TABLE IF NOT EXISTS warehouses (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    name            TEXT NOT NULL,\n    code            TEXT UNIQUE NOT NULL,\n    location        TEXT NOT NULL,\n    latitude        REAL,\n    longitude       REAL,\n    capacity        INTEGER,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS suppliers (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    name            TEXT NOT NULL,\n    contact_name    TEXT,\n    phone           TEXT,\n    email           TEXT,\n    address         TEXT,\n    rating          REAL NOT NULL DEFAULT 0.0,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS customers (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    name            TEXT NOT NULL,\n    type            TEXT NOT NULL CHECK (type IN ('individual','business')),\n    contact_name    TEXT,\n    phone           TEXT,\n    email           TEXT,\n    address         TEXT NOT NULL,\n    latitude        REAL,\n    longitude       REAL,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\n-- =========================\n-- 2) Products & Inventory\n-- =========================\n\nCREATE TABLE IF NOT EXISTS products (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    sku             TEXT NOT NULL UNIQUE,\n    name            TEXT NOT NULL,\n    description     TEXT,\n    category        TEXT,\n    weight          REAL,\n    volume          REAL,\n    unit_price      REAL NOT NULL CHECK (unit_price >= 0),\n    reorder_level   INTEGER NOT NULL DEFAULT 10 CHECK (reorder_level >= 0),\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS inventory (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE CASCADE,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE CASCADE,\n    quantity        INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),\n    reserved_qty    INTEGER NOT NULL DEFAULT 0 CHECK (reserved_qty >= 0),\n    last_updated    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE (warehouse_id, product_id)\n);\n\n-- =========================\n-- 3) Orders & Fulfillment\n-- =========================\n\nCREATE TABLE IF NOT EXISTS orders (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    customer_id     INTEGER NOT NULL REFERENCES customers(id) ON DELETE RESTRICT,\n    status          TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending','allocated','shipped','delivered','cancelled')),\n    priority        INTEGER NOT NULL DEFAULT 0,\n    order_date      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    shipped_date    DATETIME,\n    delivered_date  DATETIME\n);\n\nCREATE TABLE IF NOT EXISTS order_items (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    order_id        INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    quantity        INTEGER NOT NULL CHECK (quantity > 0),\n    unit_price      REAL NOT NULL CHECK (unit_price >= 0),\n    allocated_qty   INTEGER NOT NULL DEFAULT 0 CHECK (allocated_qty >= 0)\n);\n\n-- =========================\n-- 4) Shipments & Tracking\n-- =========================\n\nCREATE TABLE IF NOT EXISTS shipments (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    order_id        INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    carrier         TEXT,\n    tracking_number TEXT,\n    status          TEXT NOT NULL DEFAULT 'preparing' CHECK (status IN ('preparing','in_transit','delivered','failed')),\n    ship_date       DATETIME,\n    expected_date   DATETIME,\n    delivered_date  DATETIME\n);\n\nCREATE TABLE IF NOT EXISTS shipment_items (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    shipment_id     INTEGER NOT NULL REFERENCES shipments(id) ON DELETE CASCADE,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    quantity        INTEGER NOT NULL CHECK (quantity > 0)\n);\n\n-- =========================\n-- 5) Purchases & Restocking\n-- =========================\n\nCREATE TABLE IF NOT EXISTS purchase_orders (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    supplier_id     INTEGER NOT NULL REFERENCES suppliers(id) ON DELETE RESTRICT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    status          TEXT NOT NULL DEFAULT 'requested' CHECK (status IN ('requested','approved','shipped','received','cancelled')),\n    order_date      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    received_date   DATETIME\n);\n\nCREATE TABLE IF NOT EXISTS purchase_order_items (\n    id                  INTEGER PRIMARY KEY AUTOINCREMENT,\n    purchase_order_id   INTEGER NOT NULL REFERENCES purchase_orders(id) ON DELETE CASCADE,\n    product_id          INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    quantity            INTEGER NOT NULL CHECK (quantity > 0),\n    unit_price          REAL NOT NULL CHECK (unit_price >= 0)\n);\n\n-- =========================\n-- 6) Movements & Audits\n-- =========================\n\nCREATE TABLE IF NOT EXISTS stock_movements (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    movement_type   TEXT NOT NULL CHECK (movement_type IN ('inbound','outbound','transfer','adjustment')),\n    quantity        INTEGER NOT NULL CHECK (quantity <> 0),\n    reference_id    INTEGER,\n    reference_type  TEXT CHECK (reference_type IN ('order','purchase','shipment','manual')),\n    timestamp       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    notes           TEXT\n);\n\nCREATE TABLE IF NOT EXISTS inventory_audits (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    warehouse_id    INTEGER NOT NULL REFERENCES warehouses(id) ON DELETE RESTRICT,\n    product_id      INTEGER NOT NULL REFERENCES products(id) ON DELETE RESTRICT,\n    system_qty      INTEGER NOT NULL,\n    physical_qty    INTEGER NOT NULL,\n    discrepancy     INTEGER NOT NULL,\n    audit_date      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    auditor         TEXT\n);\n\n-- =========================\n-- 7) Users & Permissions\n-- =========================\n\nCREATE TABLE IF NOT EXISTS users (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    username        TEXT NOT NULL UNIQUE,\n    password_hash   TEXT NOT NULL,\n    role            TEXT NOT NULL CHECK (role IN ('admin','manager','staff','driver')),\n    full_name       TEXT,\n    email           TEXT UNIQUE,\n    created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE IF NOT EXISTS user_actions (\n    id              INTEGER PRIMARY KEY AUTOINCREMENT,\n    user_id         INTEGER NOT NULL REFERENCES users(id) ON DELETE SET NULL,\n    action          TEXT NOT NULL,\n    target_table    TEXT,\n    target_id       INTEGER,\n    timestamp       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    details         TEXT\n);\n\n-- =========================\n-- 8) Indices\n-- =========================\n\nCREATE INDEX IF NOT EXISTS idx_inventory_wh_product ON inventory(warehouse_id, product_id);\nCREATE INDEX IF NOT EXISTS idx_orders_customer ON orders(customer_id);\nCREATE INDEX IF NOT EXISTS idx_order_items_order ON order_items(order_id);\nCREATE INDEX IF NOT EXISTS idx_order_items_product ON order_items(product_id);\nCREATE INDEX IF NOT EXISTS idx_shipments_order ON shipments(order_id);\nCREATE INDEX IF NOT EXISTS idx_purchase_orders_supplier ON purchase_orders(supplier_id);\nCREATE INDEX IF NOT EXISTS idx_stock_movements_wh_prod ON stock_movements(warehouse_id, product_id);\nCREATE INDEX IF NOT EXISTS idx_products_sku ON products(sku);\n\n-- =========================\n-- 9) Triggers (timestamps & guards)\n-- =========================\n\n-- warehouses.updated_at auto-update\nCREATE TRIGGER IF NOT EXISTS trg_warehouses_updated_at\nAFTER UPDATE ON warehouses\nFOR EACH ROW\nBEGIN\n    UPDATE warehouses SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;\nEND;\n\n-- inventory.last_updated auto-update\nCREATE TRIGGER IF NOT EXISTS trg_inventory_last_updated\nAFTER UPDATE ON inventory\nFOR EACH ROW\nBEGIN\n    UPDATE inventory SET last_updated = CURRENT_TIMESTAMP WHERE id = NEW.id;\nEND;\n\n-- Prevent reserved > quantity\nCREATE TRIGGER IF NOT EXISTS trg_inventory_reserved_guard\nBEFORE UPDATE ON inventory\nFOR EACH ROW\nBEGIN\n    SELECT\n        CASE\n            WHEN NEW.reserved_qty > NEW.quantity THEN\n                RAISE(ABORT, 'reserved_qty cannot exceed quantity')\n        END;\nEND;\n\n-- Keep allocated_qty within order item quantity\nCREATE TRIGGER IF NOT EXISTS trg_order_items_alloc_guard\nBEFORE UPDATE ON order_items\nFOR EACH ROW\nBEGIN\n    SELECT\n        CASE\n            WHEN NEW.allocated_qty > NEW.quantity THEN\n                RAISE(ABORT, 'allocated_qty cannot exceed ordered quantity')\n        END;\nEND;\n\nCOMMIT;",
  "example_queries": "-- 1. Top 5 customers by total order value\nSELECT T2.name, SUM(T3.quantity * T3.unit_price) AS total_value FROM orders AS T1 INNER JOIN customers AS T2 ON T1.customer_id = T2.id INNER JOIN order_items AS T3 ON T1.id = T3.order_id GROUP BY T2.id ORDER BY total_value DESC LIMIT 5;\n\n-- 2. Products that are below reorder level and not restocked recently\nSELECT T1.name, T2.quantity AS stock_quantity, T1.reorder_level, MAX(T3.timestamp) AS last_inbound_date FROM products AS T1 INNER JOIN inventory AS T2 ON T1.id = T2.product_id LEFT JOIN stock_movements AS T3 ON T1.id = T3.product_id WHERE T2.quantity < T1.reorder_level AND T3.movement_type = 'inbound' GROUP BY T1.id HAVING last_inbound_date < strftime('%Y-%m-%d %H:%M:%S', date('now', '-30 days'));\n\n-- 3. Average order value per customer\nSELECT T2.name, AVG(T1.order_value) AS avg_order FROM (SELECT T1.id, T1.customer_id, SUM(T2.quantity * T2.unit_price) AS order_value FROM orders AS T1 INNER JOIN order_items AS T2 ON T1.id = T2.order_id GROUP BY T1.id) AS T1 INNER JOIN customers AS T2 ON T1.customer_id = T2.id GROUP BY T2.id;\n\n-- 4. Employees with most shipments handled\nSELECT T1.carrier, COUNT(T1.id) AS shipments FROM shipments AS T1 GROUP BY T1.carrier ORDER BY shipments DESC LIMIT 5;\n\n-- 5. Products with no orders in the last 6 months\nSELECT T1.name FROM products AS T1 WHERE NOT EXISTS (SELECT 1 FROM order_items AS T2 INNER JOIN orders AS T3 ON T2.order_id = T3.id WHERE T2.product_id = T1.id AND T3.order_date >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-6 months')));\n\n-- 6. Warehouse stock value by warehouse\nSELECT T1.name, SUM(T2.quantity * T3.unit_price) AS warehouse_value FROM warehouses AS T1 INNER JOIN inventory AS T2 ON T1.id = T2.warehouse_id INNER JOIN products AS T3 ON T2.product_id = T3.id GROUP BY T1.id ORDER BY warehouse_value DESC;\n\n-- 7. Orders that were delayed more than 7 days from order to shipment\nSELECT T1.id, T2.name, T1.order_date, T1.shipped_date FROM orders AS T1 INNER JOIN customers AS T2 ON T1.customer_id = T2.id WHERE JULIANDAY(T1.shipped_date) - JULIANDAY(T1.order_date) > 7;\n\n-- 8. Suppliers with top 3 most expensive products\nSELECT name, product_name, unit_price FROM (SELECT T1.name, T2.name AS product_name, T2.unit_price, DENSE_RANK() OVER (PARTITION BY T1.id ORDER BY T2.unit_price DESC) AS rank FROM suppliers AS T1 INNER JOIN purchase_order_items AS T3 ON T1.id = T3.purchase_order_id INNER JOIN products AS T2 ON T3.product_id = T2.id) AS T1 WHERE rank <= 3;\n\n-- 9. Monthly sales revenue trend\nSELECT strftime('%Y-%m', T1.order_date) AS month, SUM(T2.quantity * T2.unit_price) AS revenue FROM orders AS T1 INNER JOIN order_items AS T2 ON T1.id = T2.order_id GROUP BY month ORDER BY month;\n\n-- 10. Customers who ordered from multiple warehouses\nSELECT T1.name, COUNT(DISTINCT T3.warehouse_id) AS warehouse_count FROM customers AS T1 INNER JOIN orders AS T2 ON T1.id = T2.customer_id INNER JOIN shipments AS T3 ON T2.id = T3.order_id GROUP BY T1.id HAVING warehouse_count > 1;",
  "process": [
    "[SQL] Create a Common Table Expression (CTE) named `ShipmentsInLastYear` to identify all shipments that occurred within the last year (based on `ship_date`). Include `shipment_id`, `order_id`, `warehouse_id`, `customer_id` (from `orders`), `supplier_id` (by joining `shipment_items` -> `products` -> `purchase_order_items` -> `purchase_orders`), and a flag `is_delayed` (1 if `delivered_date > expected_date`, 0 otherwise).",
    "[SQL] Create a CTE named `SupplierPerformance` that aggregates data from `ShipmentsInLastYear`. For each `supplier_id`, calculate: (1) `total_shipments_count` (count of all `shipment_id`s), (2) `delayed_shipments_count` (count of `shipment_id`s where `is_delayed = 1`). Also retrieve `supplier_name` from the `suppliers` table.",
    "[SQL] Create a CTE named `SupplierDelayedWarehouses` that, for each `supplier_id`, identifies all distinct `warehouse_id`s associated with their delayed shipments from `ShipmentsInLastYear` (where `is_delayed = 1`). Join with the `warehouses` table to get `warehouse_name`s.",
    "[SQL] Create a CTE named `SupplierCustomerImpact` that, for each `supplier_id` and each `customer_id` associated with their delayed shipments (`is_delayed = 1` in `ShipmentsInLastYear`), counts the number of delayed shipments. Join with the `customers` table to get `customer_name`.",
    "[SQL] From `SupplierCustomerImpact`, for each `supplier_id`, rank customers by their `delayed_shipment_count` in descending order and select only the top 3 customers. This can be done using a window function like `ROW_NUMBER()` or `RANK()` partitioned by `supplier_id`.",
    "[ANALYZE] Combine the results from `SupplierPerformance`, `SupplierDelayedWarehouses`, and the top 3 customers from `SupplierCustomerImpact`. For each supplier, present: the supplier's name, the total number of delayed shipments, the percentage of delayed shipments (delayed_shipments_count / total_shipments_count * 100), the names of warehouses involved in those delayed shipments, and the names of the top 3 most affected customers along with their respective delayed shipment counts. If a supplier has no delayed shipments, they should not appear in the results. Handle cases where a supplier might have fewer than 3 affected customers."
  ],
  "plan": {
    "version": "1.0",
    "nodes": [
      {
        "id": "n1",
        "type": "SQL",
        "label": "Identify Shipments in Last Year and Supplier Linkage",
        "requires": "",
        "produces": "result_shipments_in_last_year,sql_query_n1",
        "input": "Create a Common Table Expression (CTE) named `ShipmentsInLastYear`. Identify all shipments that occurred within the last year (based on `ship_date`). Include `shipment_id`, `order_id` (from `shipments`), `warehouse_id` (from `shipments`), `customer_id` (by joining `shipments` to `orders`), `supplier_id` (by joining `shipment_items` -> `products` -> `purchase_order_items` -> `purchase_orders`), and a flag `is_delayed` (1 if `delivered_date > expected_date`, 0 otherwise). Make sure to handle potential NULLs for `delivered_date` or `expected_date` in the `is_delayed` calculation, considering a shipment delayed only if both dates are present and `delivered_date` is later than `expected_date`."
      },
      {
        "id": "n2",
        "type": "SQL",
        "label": "Calculate Supplier Performance Metrics",
        "requires": "result_shipments_in_last_year",
        "produces": "result_supplier_performance,sql_query_n2",
        "input": "From the `ShipmentsInLastYear` CTE (`result_shipments_in_last_year`), create a CTE named `SupplierPerformance`. For each `supplier_id`, calculate: (1) `total_shipments_count` (count of all `shipment_id`s), (2) `delayed_shipments_count` (count of `shipment_id`s where `is_delayed = 1`). Also retrieve `supplier_name` from the `suppliers` table by joining on `supplier_id`. Only include suppliers that have at least one shipment in the last year."
      },
      {
        "id": "n3",
        "type": "SQL",
        "label": "Identify Warehouses for Delayed Shipments by Supplier",
        "requires": "result_shipments_in_last_year",
        "produces": "result_supplier_delayed_warehouses,sql_query_n3",
        "input": "From the `ShipmentsInLastYear` CTE (`result_shipments_in_last_year`), create a CTE named `SupplierDelayedWarehouses`. For each `supplier_id`, identify all distinct `warehouse_id`s associated with their delayed shipments (where `is_delayed = 1`). Join with the `warehouses` table to get `warehouse_name`s. The result should list `supplier_id`, `supplier_name`, `warehouse_id`, and `warehouse_name` for each distinct combination where a delayed shipment occurred."
      },
      {
        "id": "n4",
        "type": "SQL",
        "label": "Calculate Customer Impact from Delayed Shipments by Supplier",
        "requires": "result_shipments_in_last_year",
        "produces": "result_supplier_customer_impact,sql_query_n4",
        "input": "From the `ShipmentsInLastYear` CTE (`result_shipments_in_last_year`), create a CTE named `SupplierCustomerImpact`. For each `supplier_id` and each `customer_id` associated with their delayed shipments (`is_delayed = 1`), count the number of delayed shipments (`delayed_shipment_count`). Join with the `customers` table to get `customer_name`. The output should include `supplier_id`, `customer_id`, `customer_name`, and `delayed_shipment_count`."
      },
      {
        "id": "n5",
        "type": "SQL",
        "label": "Rank and Select Top 3 Affected Customers per Supplier",
        "requires": "result_supplier_customer_impact",
        "produces": "result_top_3_customers,sql_query_n5",
        "input": "From the `SupplierCustomerImpact` CTE (`result_supplier_customer_impact`), for each `supplier_id`, rank customers by their `delayed_shipment_count` in descending order. Select only the top 3 customers for each supplier. This can be done using a window function like `ROW_NUMBER()` or `RANK()` partitioned by `supplier_id` and ordered by `delayed_shipment_count` DESC. The output should include `supplier_id`, `customer_id`, `customer_name`, `delayed_shipment_count`, and the rank."
      },
      {
        "id": "n6",
        "type": "ANALYZER",
        "label": "Generate Final Delayed Shipments Report",
        "requires": "result_supplier_performance,result_supplier_delayed_warehouses,result_top_3_customers",
        "produces": "final_delayed_shipment_report",
        "input": "Combine the results from `result_supplier_performance`, `result_supplier_delayed_warehouses`, and `result_top_3_customers`. For each supplier, present: the supplier's name, the total number of delayed shipments, the percentage of delayed shipments (calculated as `delayed_shipments_count / total_shipments_count * 100`), the names of warehouses involved in those delayed shipments (as a comma-separated string), and the names of the top 3 most affected customers along with their respective delayed shipment counts (e.g., 'Customer A (10), Customer B (8), Customer C (5)'). If a supplier has no delayed shipments (`delayed_shipments_count` is 0), they should not appear in the results. Handle cases where a supplier might have fewer than 3 affected customers (only list the ones that exist)."
      }
    ],
    "edges": [
      [
        "n1",
        "n2"
      ],
      [
        "n1",
        "n3"
      ],
      [
        "n1",
        "n4"
      ],
      [
        "n4",
        "n5"
      ],
      [
        "n2",
        "n6"
      ],
      [
        "n3",
        "n6"
      ],
      [
        "n5",
        "n6"
      ]
    ]
  },
  "artifacts": {
    "sql_query_n1": "WITH ShipmentSupplierLink AS (\n    SELECT DISTINCT\n        s.id AS shipment_id,\n        s.order_id,\n        s.warehouse_id,\n        o.customer_id,\n        po.supplier_id,\n        CASE\n            WHEN s.delivered_date IS NOT NULL AND s.expected_date IS NOT NULL AND JULIANDAY(s.delivered_date) > JULIANDAY(s.expected_date) THEN 1\n            ELSE 0\n        END AS is_delayed\n    FROM\n        shipments AS s\n    JOIN\n        orders AS o ON s.order_id = o.id\n    JOIN\n        shipment_items AS si ON s.id = si.shipment_id\n    JOIN\n        products AS p ON si.product_id = p.id\n    JOIN\n        purchase_order_items AS poi ON p.id = poi.product_id\n    JOIN\n        purchase_orders AS po ON poi.purchase_order_id = po.id\n    WHERE\n        s.ship_date >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-1 year'))\n),\nSupplierShipmentDetails AS (\n    SELECT\n        ssl.supplier_id,\n        sup.name AS supplier_name,\n        ssl.shipment_id,\n        ssl.warehouse_id,\n        w.name AS warehouse_name,\n        ssl.customer_id,\n        c.name AS customer_name,\n        ssl.is_delayed\n    FROM\n        ShipmentSupplierLink AS ssl\n    JOIN\n        suppliers AS sup ON ssl.supplier_id = sup.id\n    JOIN\n        warehouses AS w ON ssl.warehouse_id = w.id\n    JOIN\n        customers AS c ON ssl.customer_id = c.id\n),\nSupplierPerformanceMetrics AS (\n    SELECT\n        supplier_id,\n        supplier_name,\n        SUM(is_delayed) AS total_delayed_shipments,\n        COUNT(DISTINCT shipment_id) AS total_shipments,\n        (CAST(SUM(is_delayed) AS REAL) * 100.0 / COUNT(DISTINCT shipment_id)) AS percentage_delayed,\n        GROUP_CONCAT(DISTINCT warehouse_name) AS warehouses_handled\n    FROM\n        SupplierShipmentDetails\n    GROUP BY\n        supplier_id, supplier_name\n),\nCustomerDelayedShipmentCounts AS (\n    SELECT\n        supplier_id,\n        customer_id,\n        customer_name,\n        SUM(is_delayed) AS delayed_shipments_to_customer\n    FROM\n        SupplierShipmentDetails\n    WHERE\n        is_delayed = 1\n    GROUP BY\n        supplier_id, customer_id, customer_name\n),\nRankedTopCustomers AS (\n    SELECT\n        supplier_id,\n        customer_name,\n        delayed_shipments_to_customer,\n        ROW_NUMBER() OVER (PARTITION BY supplier_id ORDER BY delayed_shipments_to_customer DESC, customer_name) AS rn\n    FROM\n        CustomerDelayedShipmentCounts\n)\nSELECT\n    spm.supplier_name,\n    spm.total_delayed_shipments,\n    printf(\"%.2f%%\", spm.percentage_delayed) AS percentage_delayed,\n    spm.warehouses_handled,\n    GROUP_CONCAT(rtc.customer_name || ' (' || rtc.delayed_shipments_to_customer || ' delayed)') AS top_3_affected_customers\nFROM\n    SupplierPerformanceMetrics AS spm\nLEFT JOIN\n    RankedTopCustomers AS rtc ON spm.supplier_id = rtc.supplier_id AND rtc.rn <= 3\nGROUP BY\n    spm.supplier_id, spm.supplier_name, spm.total_delayed_shipments, spm.percentage_delayed, spm.warehouses_handled\nORDER BY\n    spm.total_delayed_shipments DESC, spm.supplier_name;"
  },
  "executed_queries": [
    "WITH ShipmentSupplierLink AS (\n    SELECT DISTINCT\n        s.id AS shipment_id,\n        s.order_id,\n        s.warehouse_id,\n        o.customer_id,\n        po.supplier_id,\n        CASE\n            WHEN s.delivered_date IS NOT NULL AND s.expected_date IS NOT NULL AND JULIANDAY(s.delivered_date) > JULIANDAY(s.expected_date) THEN 1\n            ELSE 0\n        END AS is_delayed\n    FROM\n        shipments AS s\n    JOIN\n        orders AS o ON s.order_id = o.id\n    JOIN\n        shipment_items AS si ON s.id = si.shipment_id\n    JOIN\n        products AS p ON si.product_id = p.id\n    JOIN\n        purchase_order_items AS poi ON p.id = poi.product_id\n    JOIN\n        purchase_orders AS po ON poi.purchase_order_id = po.id\n    WHERE\n        s.ship_date >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-1 year'))\n),\nSupplierShipmentDetails AS (\n    SELECT\n        ssl.supplier_id,\n        sup.name AS supplier_name,\n        ssl.shipment_id,\n        ssl.warehouse_id,\n        w.name AS warehouse_name,\n        ssl.customer_id,\n        c.name AS customer_name,\n        ssl.is_delayed\n    FROM\n        ShipmentSupplierLink AS ssl\n    JOIN\n        suppliers AS sup ON ssl.supplier_id = sup.id\n    JOIN\n        warehouses AS w ON ssl.warehouse_id = w.id\n    JOIN\n        customers AS c ON ssl.customer_id = c.id\n),\nSupplierPerformanceMetrics AS (\n    SELECT\n        supplier_id,\n        supplier_name,\n        SUM(is_delayed) AS total_delayed_shipments,\n        COUNT(DISTINCT shipment_id) AS total_shipments,\n        (CAST(SUM(is_delayed) AS REAL) * 100.0 / COUNT(DISTINCT shipment_id)) AS percentage_delayed,\n        GROUP_CONCAT(DISTINCT warehouse_name) AS warehouses_handled\n    FROM\n        SupplierShipmentDetails\n    GROUP BY\n        supplier_id, supplier_name\n),\nCustomerDelayedShipmentCounts AS (\n    SELECT\n        supplier_id,\n        customer_id,\n        customer_name,\n        SUM(is_delayed) AS delayed_shipments_to_customer\n    FROM\n        SupplierShipmentDetails\n    WHERE\n        is_delayed = 1\n    GROUP BY\n        supplier_id, customer_id, customer_name\n),\nRankedTopCustomers AS (\n    SELECT\n        supplier_id,\n        customer_name,\n        delayed_shipments_to_customer,\n        ROW_NUMBER() OVER (PARTITION BY supplier_id ORDER BY delayed_shipments_to_customer DESC, customer_name) AS rn\n    FROM\n        CustomerDelayedShipmentCounts\n)\nSELECT\n    spm.supplier_name,\n    spm.total_delayed_shipments,\n    printf(\"%.2f%%\", spm.percentage_delayed) AS percentage_delayed,\n    spm.warehouses_handled,\n    GROUP_CONCAT(rtc.customer_name || ' (' || rtc.delayed_shipments_to_customer || ' delayed)') AS top_3_affected_customers\nFROM\n    SupplierPerformanceMetrics AS spm\nLEFT JOIN\n    RankedTopCustomers AS rtc ON spm.supplier_id = rtc.supplier_id AND rtc.rn <= 3\nGROUP BY\n    spm.supplier_id, spm.supplier_name, spm.total_delayed_shipments, spm.percentage_delayed, spm.warehouses_handled\nORDER BY\n    spm.total_delayed_shipments DESC, spm.supplier_name;"
  ],
  "node_status": {
    "n1": {
      "state": "succeeded",
      "attempts": 1,
      "last_error": null
    },
    "n2": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    },
    "n3": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    },
    "n4": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    },
    "n5": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    },
    "n6": {
      "state": "pending",
      "attempts": 0,
      "last_error": null
    }
  },
  "current_node_id": "n1",
  "last_output": {
    "status": "ok",
    "artifacts": {
      "sql_query_n1": "WITH ShipmentSupplierLink AS (\n    SELECT DISTINCT\n        s.id AS shipment_id,\n        s.order_id,\n        s.warehouse_id,\n        o.customer_id,\n        po.supplier_id,\n        CASE\n            WHEN s.delivered_date IS NOT NULL AND s.expected_date IS NOT NULL AND JULIANDAY(s.delivered_date) > JULIANDAY(s.expected_date) THEN 1\n            ELSE 0\n        END AS is_delayed\n    FROM\n        shipments AS s\n    JOIN\n        orders AS o ON s.order_id = o.id\n    JOIN\n        shipment_items AS si ON s.id = si.shipment_id\n    JOIN\n        products AS p ON si.product_id = p.id\n    JOIN\n        purchase_order_items AS poi ON p.id = poi.product_id\n    JOIN\n        purchase_orders AS po ON poi.purchase_order_id = po.id\n    WHERE\n        s.ship_date >= strftime('%Y-%m-%d %H:%M:%S', date('now', '-1 year'))\n),\nSupplierShipmentDetails AS (\n    SELECT\n        ssl.supplier_id,\n        sup.name AS supplier_name,\n        ssl.shipment_id,\n        ssl.warehouse_id,\n        w.name AS warehouse_name,\n        ssl.customer_id,\n        c.name AS customer_name,\n        ssl.is_delayed\n    FROM\n        ShipmentSupplierLink AS ssl\n    JOIN\n        suppliers AS sup ON ssl.supplier_id = sup.id\n    JOIN\n        warehouses AS w ON ssl.warehouse_id = w.id\n    JOIN\n        customers AS c ON ssl.customer_id = c.id\n),\nSupplierPerformanceMetrics AS (\n    SELECT\n        supplier_id,\n        supplier_name,\n        SUM(is_delayed) AS total_delayed_shipments,\n        COUNT(DISTINCT shipment_id) AS total_shipments,\n        (CAST(SUM(is_delayed) AS REAL) * 100.0 / COUNT(DISTINCT shipment_id)) AS percentage_delayed,\n        GROUP_CONCAT(DISTINCT warehouse_name) AS warehouses_handled\n    FROM\n        SupplierShipmentDetails\n    GROUP BY\n        supplier_id, supplier_name\n),\nCustomerDelayedShipmentCounts AS (\n    SELECT\n        supplier_id,\n        customer_id,\n        customer_name,\n        SUM(is_delayed) AS delayed_shipments_to_customer\n    FROM\n        SupplierShipmentDetails\n    WHERE\n        is_delayed = 1\n    GROUP BY\n        supplier_id, customer_id, customer_name\n),\nRankedTopCustomers AS (\n    SELECT\n        supplier_id,\n        customer_name,\n        delayed_shipments_to_customer,\n        ROW_NUMBER() OVER (PARTITION BY supplier_id ORDER BY delayed_shipments_to_customer DESC, customer_name) AS rn\n    FROM\n        CustomerDelayedShipmentCounts\n)\nSELECT\n    spm.supplier_name,\n    spm.total_delayed_shipments,\n    printf(\"%.2f%%\", spm.percentage_delayed) AS percentage_delayed,\n    spm.warehouses_handled,\n    GROUP_CONCAT(rtc.customer_name || ' (' || rtc.delayed_shipments_to_customer || ' delayed)') AS top_3_affected_customers\nFROM\n    SupplierPerformanceMetrics AS spm\nLEFT JOIN\n    RankedTopCustomers AS rtc ON spm.supplier_id = rtc.supplier_id AND rtc.rn <= 3\nGROUP BY\n    spm.supplier_id, spm.supplier_name, spm.total_delayed_shipments, spm.percentage_delayed, spm.warehouses_handled\nORDER BY\n    spm.total_delayed_shipments DESC, spm.supplier_name;"
    },
    "notes": "This query identifies suppliers indirectly responsible for delayed shipments in the last year, calculating the number and percentage of delayed shipments, the warehouses involved, and the top 3 most affected customers for each supplier.",
    "stats": {
      "elapsed_ms": 9,
      "rows_affected": -1
    },
    "error": null
  },
  "total_attempts": 1,
  "issues": []
}